#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <stdexcept>

using namespace std;

// Helper function to compute value mod 27 (ensures positive result)
int mod27(int val) {
    return (val % 27 + 27) % 27; // Ensures the result is always positive
}

// Helper to multiply a 2x2 matrix with a vector [x, y]
pair<int, int> multiplyMatrixVector(int x, int y, const vector<vector<int>>& matrix) {
    int a = matrix[0][0], b = matrix[0][1]; // Matrix elements
    int c = matrix[1][0], d = matrix[1][1];
    return {mod27(x * a + y * c), mod27(x * b + y * d)}; // Return transformed vector
}

// Function prototypes
vector<vector<int>> generateKeyMatrix(); // Generates a random 2x2 key matrix
string matrixToKey(const vector<vector<int>>& keyMatrix); // Converts matrix to a 4-letter key
vector<int> processMessage(const string& message); // Converts message to numerical form
vector<int> encrypt(const vector<int>& numbers, const vector<vector<int>>& keyMatrix); // Encrypts message
vector<int> decrypt(const vector<int>& numbers, const vector<vector<int>>& invMatrix); // Decrypts message
string numbersToText(const vector<int>& numbers); // Converts numbers back to text
vector<vector<int>> keyToMatrix(const string& key); // Converts 4-letter key to matrix
int modInverse(int a, int m); // Computes modular inverse
vector<vector<int>> inverseMatrix(const vector<vector<int>>& keyMatrix); // Computes inverse of a matrix
int gcd(int a, int b); // Computes greatest common divisor
bool isKeyValid(const vector<vector<int>>& keyMatrix); // Checks if key matrix is valid
void handleEncryption(); // Handles encryption process
void handleDecryption(); // Handles decryption process

int main() {
    srand(time(0)); // Seed random number generator with current time

    int choice;
    do {
        cout << "Hill Cipher System\n1. Encrypt\n2. Decrypt\n3. Exit\nEnter choice: ";
        cin >> choice; // Get user choice
        cin.ignore(); // Clear input buffer

        switch (choice) {
            case 1: handleEncryption(); break; // Call encryption handler
            case 2: handleDecryption(); break; // Call decryption handler
            case 3: break; // Exit the program
            default: cout << "Invalid choice.\n"; // Handle invalid input
        }
    } while (choice != 3); // Loop until user chooses to exit

    return 0;
}

// Handles the encryption process
void handleEncryption() {
    vector<vector<int>> keyMatrix = generateKeyMatrix(); // Generate a random key matrix
    cout << "Generated Key: " << matrixToKey(keyMatrix) << endl; // Display the key

    string message;
    cout << "Enter message to encrypt: ";
    getline(cin, message); // Get message from user

    vector<int> numbers = processMessage(message); // Convert message to numbers
    string ciphertext = numbersToText(encrypt(numbers, keyMatrix)); // Encrypt and convert to text
    cout << "Encrypted: " << ciphertext << "\nSave key: " << matrixToKey(keyMatrix) << "\n\n";
}

// Handles the decryption process
void handleDecryption() {
    string ciphertext, keyStr;
    cout << "Enter encrypted message: ";
    getline(cin, ciphertext); // Get encrypted message
    cout << "Enter encryption key (4 letters A-I): ";
    getline(cin, keyStr); // Get encryption key

    vector<vector<int>> keyMatrix;
    try {
        keyMatrix = keyToMatrix(keyStr); // Convert key to matrix
    } catch (const invalid_argument& e) {
        cout << "Error: " << e.what() << endl; // Handle invalid key
        return;
    }

    if (!isKeyValid(keyMatrix)) { // Check if key is valid
        cout << "Invalid key: determinant not invertible modulo 27.\n";
        return;
    }

    vector<vector<int>> invMatrix;
    try {
        invMatrix = inverseMatrix(keyMatrix); // Compute inverse matrix
    } catch (const invalid_argument& e) {
        cout << "Error: " << e.what() << endl; // Handle non-invertible matrix
        return;
    }

    vector<int> numbers = processMessage(ciphertext); // Convert ciphertext to numbers
    string plaintext = numbersToText(decrypt(numbers, invMatrix)); // Decrypt and convert to text
    cout << "Decrypted message: " << plaintext << "\n\n";
}

vector<vector<int>> generateKeyMatrix() {
    int a, b, c, d, det;
    while (true) {
        a = rand() % 9 + 1;  
        b = rand() % 9 + 1;
        c = rand() % 9 + 1;
        d = rand() % 9 + 1;
        det = a * d - b * c; 
        
        if (det % 3 != 0) { 
            break; 
        }
    }
    return {{a, b}, {c, d}};
}

string matrixToKey(const vector<vector<int>>& keyMatrix) {
    string key;
    for (auto& row : keyMatrix) // Iterate through matrix rows
        for (int val : row) // Iterate through matrix columns
            key += 'A' + val - 1; // Convert number to letter (A-I)
    return key;
}

// Converts a message to a vector of numbers (A=1, B=2, ..., space=0)
vector<int> processMessage(const string& message) {
    vector<int> numbers;
    for (char c : message) {
        if (c == ' ') numbers.push_back(0); // Space is represented as 0
        else if (isalpha(c)) numbers.push_back(toupper(c) - 'A' + 1); // Convert letter to number
    }
    if (numbers.size() % 2 != 0) numbers.push_back(0); // Pad with 0 if odd length
    return numbers;
}

// Encrypts a vector of numbers using the key matrix
vector<int> encrypt(const vector<int>& numbers, const vector<vector<int>>& keyMatrix) {
    vector<int> encrypted;
    for (size_t i = 0; i < numbers.size(); i += 2) { // Process pairs of numbers
        auto [ex, ey] = multiplyMatrixVector(numbers[i], numbers[i+1], keyMatrix); // Multiply matrix with vector
        encrypted.insert(encrypted.end(), {ex, ey}); // Add encrypted pair to result
    }
    return encrypted;
}

// Decrypts a vector of numbers using the inverse matrix
vector<int> decrypt(const vector<int>& numbers, const vector<vector<int>>& invMatrix) {
    vector<int> decrypted;
    for (size_t i = 0; i < numbers.size(); i += 2) { // Process pairs of numbers
        auto [dx, dy] = multiplyMatrixVector(numbers[i], numbers[i+1], invMatrix); // Multiply with inverse matrix
        decrypted.insert(decrypted.end(), {dx, dy}); // Add decrypted pair to result
    }
    return decrypted;
}

// Converts a vector of numbers back to text
string numbersToText(const vector<int>& numbers) {
    string text;
    for (int num : numbers)
        text += (num == 0) ? ' ' : ('A' + num - 1); // Convert number to letter or space
    return text;
}

// Converts a 4-letter key to a 2x2 matrix
vector<vector<int>> keyToMatrix(const string& key) {
    if (key.size() != 4) throw invalid_argument("Key must be 4 characters."); // Validate key length
    vector<vector<int>> matrix(2, vector<int>(2));
    for (size_t i = 0; i < 4; ++i) {
        char c = toupper(key[i]); // Convert to uppercase
        if (c < 'A' || c > 'I') throw invalid_argument("Key characters must be A-I."); // Validate characters
        matrix[i/2][i%2] = c - 'A' + 1; // Convert letter to number and store in matrix
    }
    return matrix;
}

// Computes the modular inverse of a number
int modInverse(int a, int m) {
    int original_mod = m, y = 0, x = 1;
    if (m == 1) return 0; // Edge case
    while (a > 1) { // Extended Euclidean algorithm
        int q = a / m;
        tie(a, m) = make_pair(m, a % m);
        tie(x, y) = make_pair(y, x - q * y);
    }
    return x < 0 ? x + original_mod : x; // Ensure positive result
}

// Computes the inverse of a 2x2 matrix
vector<vector<int>> inverseMatrix(const vector<vector<int>>& keyMatrix) {
    int det = mod27(keyMatrix[0][0] * keyMatrix[1][1] - keyMatrix[0][1] * keyMatrix[1][0]); // Compute determinant
    if (det == 0 || gcd(det, 27) != 1) throw invalid_argument("Matrix not invertible."); // Check if invertible

    int invDet = modInverse(det, 27); // Compute modular inverse of determinant
    return {{
        mod27(keyMatrix[1][1] * invDet), // Compute inverse matrix elements
        mod27(-keyMatrix[0][1] * invDet)
    }, {
        mod27(-keyMatrix[1][0] * invDet),
        mod27(keyMatrix[0][0] * invDet)
    }};
}

// Computes the greatest common divisor of two numbers
int gcd(int a, int b) {
    while (b) { int t = b; b = a % b; a = t; } // Euclidean algorithm
    return a;
}

// Checks if a key matrix is valid (determinant coprime with 27)
bool isKeyValid(const vector<vector<int>>& keyMatrix) {
    int det = mod27(keyMatrix[0][0] * keyMatrix[1][1] - keyMatrix[0][1] * keyMatrix[1][0]); // Compute determinant
    return det != 0 && gcd(det, 27) == 1; // Check if determinant is valid
}
